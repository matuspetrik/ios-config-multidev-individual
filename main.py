import csv
import threading
import time
import datetime
import glob
import os
import sys
#import traceback
from queue import Queue
from getpass import getpass
from netmiko import ConnectHandler
# from netmiko.ssh_exception import NetMikoTimeoutException
# from netmiko.ssh_exception import NetMikoAuthenticationException
# from paramiko.ssh_exception import NoValidConnectionsError, SSHException
# import paramiko
import logging
import Lib.Configurations as configs
import Lib.Worker as worker

if os.path.exists(os.getcwd()+"/test.log"):
    os.remove(os.getcwd()+"/test.log")
logger = logging.getLogger("netmiko")
logging.basicConfig(filename='test.log', level=logging.DEBUG)

if os.path.exists(os.getcwd()+"/logs/result.log"):
    os.remove(os.getcwd()+"/logs/result.log")

# Define username and password to login to all routers with
datetime_now = str(datetime.datetime.now()).replace(" ","-")
datetime_now = datetime_now.replace(":","-")
datetime_now = datetime_now.replace(".","-")
#PATH = '/home/mp752k/testoutput/out-'+datetime_now+'/'     #trailing slash is veery important
#PATH = os.getcwd()+"/raw_data/br013-2019-11-25-19-34-01-400260/logs/" #trailing slash is veery important, path where log files will be stored
PATH_INPUT = os.getcwd()+"/config/" #trailing slash is veery important, path for config files
#print(PATH)
#print(PATH_INPUT)
print("******************************************************************************************************************************************")
print("*                                                                                                                                        *")
print("*                [3/3], USING THIS APPLICATION YOU WILL PUSH THE CONFIGURATION TO THE DEVICES. \
PLEASE, BE CAREFUL!                       *")
print("*                                                                                                                                        *")
print("******************************************************************************************************************************************")

print("=== [1/3] INPUT - WHERE THE LOGS WILL BE STORED: ")
PATH = os.getcwd()+"/logs/"
line = ''
site_id = ''
is_folder_generated = False
while True:
    try:
        line = input(PATH)
        if line == '':
#            print("=== [1/2] OKAY, AT LEAST PROVIDE SITE ID OR DESCRIPTION: ")
            site_id = input("=== [1/3] OKAY, AT LEAST PROVIDE SITE ID OR DESCRIPTION: ")
            if site_id == '':
                line = datetime_now
            else:
                line = site_id+"-"+datetime_now
            is_folder_generated = True
        break
    except EOFError:
        break
PATH = PATH+line

# if trailing slash is missing, add it to the PATH string
if PATH[-1:] != "/":
    PATH = PATH+"/"

if is_folder_generated == True:
    print("Store folder autogenerated ... "+PATH)
is_folder_generated = False

# Create PATH directory
if not os.path.exists(PATH):
    os.makedirs(PATH)

# Get the PATH where the configuration files are stored
print()
print("=== [2/3] INPUT - CONFIG FILES ABSOLUTE PATH:")
default_path = os.getcwd()+"/"
# print("==== Are your config files are in: "+PATH_INPUT+"[Y/n]")
line = input("Your config files are in: "+PATH_INPUT+" [Y/n] ")
if line == "Y" or line == "y" or line == "":
    pass
else:
    while True:
        line = input("Define where your config files are stored: "+default_path)
        PATH_INPUT = default_path+line
        if os.path.exists(PATH_INPUT):
            break
        else:
            print("!!! Directory "+PATH_INPUT+" not found!!! Define existing directory...")
line = ''

print("I will search for your config files in: "+PATH_INPUT)
# if trailing slash is missing, add it to the PATH string
if PATH_INPUT[-1:] != "/":
    PATH_INPUT = PATH_INPUT+"/"

LIST_OF_FILES = os.listdir(PATH_INPUT) # returns list

print()
# Get input of IP addresses to be processed
print("=== [3/3] INPUT - IPv4 ADDRESSES: \n=== *one per line; it is ok to input blank lines")
ROUTERS = []
line = ''
while True:
    try:
        line = input()
        if not line.strip():
            break
    except EOFError:
        break
    ROUTERS.append(line.strip())
line = ''

ROUTERS = list(filter(None, ROUTERS)) # fastest (remove blank lines from the list)
routers_0 = []
for router in ROUTERS:
    if "/" in router:
        routers_0.append(router.split('/')[0])
    else:
        routers_0.append(router)
ROUTERS = routers_0
print(ROUTERS)
routers = []
routers_notfound = []

routers = set(ROUTERS) & set(LIST_OF_FILES) # find cross-section of two lists
routers_notfound = set(ROUTERS) - set(routers)

if len(routers_notfound) > 0:
    print("WARNING! Config file was not found for following IP(s):")
    for i in routers_notfound:
        print(i)
    line = input("Terminate application? [Y/n] ")
    if line == "Y" or line == "y" or line == "":
        sys.exit()
    else:
        for i in routers_notfound:
            print(f"Creating a blank file for {i}")
            file_path = PATH_INPUT+i
            with open(file_path, 'w') as file:
                pass  # No content is written to the file
        pass
routers = list(routers)
print("=======================================================================================================================")
print("=== FOLLOWING DEVICES WILL BE CONFIGURED:",routers)
print("=== TOTAL NUMBER OF DEVICES TO BE CONFIGURED:",len(routers))
print("=======================================================================================================================")
print("=== CONFIG FILES ARE STORED AT:", PATH_INPUT)
print("=======================================================================================================================")
print("=== THE OUTPUT FILES WILL BE STORED AT:", PATH)
print("=== THE RESULT FILE WILL BE STORED AT: ", os.getcwd()+"/logs/result.log")
print("=== SCRIPT OUTPUT CAN BE VIEWED AT:     tail -f", os.getcwd()+"/test.log")
print("=======================================================================================================================")

USER = input('Your MechID: ')
PASSWORD = getpass(prompt='Password: ', stream=None)
SECRET = PASSWORD


#print(COMMMANDS)

# Define router IPs, you could also make a dictionary imported from a CSV file, or create a list from a text file of hostnames
# routers = [
#"10.94.26.6",  #GS293ZbvR070L-12
#"10.94.26.8",  #GS293ZbvR077L-21
#"10.94.47.66", #GS293ZbvGUA39-01
#"10.94.45.2"   #GS293Zbv0000A-01

# "10.71.50.130",
# "10.71.52.2"

# ]


# def session_worker_cisco_ios(hostname, output_q, router, output_dict, method):
#    # output_dict = {}
#     with open(PATH_INPUT+hostname) as f:
#         lines = f.read().splitlines()
#     device_session = ConnectHandler(**router)
#     time.sleep(2)
#     #device_session.enable()
#     output_list = []
#     output_dict[hostname+"_"+method] = ""
#     output = "##############################################\r\n# Device config started at: "+str(datetime.datetime.now())+" #\r\n##############################################\r\n"
#     output += device_session.send_config_set(lines, delay_factor=4)
#     #output += device_session.send_command("write\r\n")  # uncomment if you want the config to be written
#     #output += device_session.send_command("\r\n") 
#     #output += device_session.save_config() 
# #    output = net_connect.send_command_timing(command)
#     #print(output)
#     if "confirm" in output:
#         output += net_connect.send_command_timing("y", strip_prompt=False, strip_command=False) # in case 'y' confirmation is needed
#     output += device_session.save_config()
#     with open(PATH+hostname,'a+') as the_file:
#         the_file.write(output)
#         the_file.write("\r\n")
#     output_dict[hostname+".log"]  = output
#     output_q.put(output_dict)
#     time.sleep(2)
#     device_session.disconnect()



def session(router, output_q, id):
    # Place what you want each thread to do here, for example connect to SSH, run a command, get output
    time.sleep(id)
    hostname    = router
    router_ip   = router
    output_dict = {}
    device_type = configs.identify_config(PATH_INPUT+hostname)
    print(device_type)
    try:
        # router =    {   'device_type': 'cisco_ios_ssh', 
        router =    {   'device_type': device_type, 
                        'ip': router_ip, 
                        'username': USER, 
                        'password': PASSWORD, 
                        'secret': SECRET, 
                        # 'verbose': False,
                        'verbose': True,
                        'ssh_config_file': '~/.ssh/config',
#                        'global_delay_factor': 1
                    }
        if 'mikrotik' in device_type:
            print(router)
            worker.session_worker_mikrotik(hostname, output_q, router, output_dict, method="ssh", PATH_INPUT=PATH_INPUT, PATH=PATH)
        elif 'cisco_ios' in device_type:
            worker.session_worker_cisco_ios(hostname, output_q, router, output_dict, method="ssh")
        time.sleep(1)
        string = "SSH: "+router_ip
        print(string)
        with open(os.getcwd()+'/logs/result.log', 'a') as file:  # Use file to refer to the file object
            file.write(string+"\n")
    except:
        try:
            router = {  'device_type': 'cisco_ios_telnet', 
                        'ip': router_ip, 
                        'username': USER, 
                        'password': PASSWORD, 
                        'secret': SECRET, 
                        'verbose': False
                    }
            if 'mikrotik' in device_type:
                worker.session_worker_mikrotik(hostname, output_q, router, output_dict, method="telnet")
            elif 'cisco_ios' in device_type:
                worker.session_worker_cisco_ios(hostname, output_q, router, output_dict, method="telnet")
            time.sleep(1)
            string = "Telnet: "+ router_ip
            print(string)
            with open(os.getcwd()+'/logs/result.log', 'a') as file:  # Use file to refer to the file object
                file.write(string+"\n")
        except:#  (NoValidConnectionsError, NetMikoTimeoutException):
            string = "Failed: " + router_ip
            print(string)
            with open(os.getcwd()+'/logs/result.log', 'a') as file:  # Use file to refer to the file object
                file.write(string+"\n")
            output = "Failed"
            output_dict[hostname+"_ERR_FAILED_TIMEOUT"]  = output
            output_q.put(output_dict)


if __name__ == "__main__":

    output_q = Queue()

    # Start thread for each router in routers list
    id=0
    for router in routers:
        time.sleep(1)
        #print(router)
        my_thread = threading.Thread(target=session, args=(router, output_q, id))
        my_thread.start()
        id=id+1

    # Wait for all threads to complete
    main_thread = threading.currentThread()
    for some_thread in threading.enumerate():
        if some_thread != main_thread:
            some_thread.join()

    # Retrieve everything off the queue - k is the router IP, v is output
    # You could also write this to a file, or create a file for each router

    while not output_q.empty():
        my_dict = output_q.get()
#        for k, val in my_dict.items():
#            with open(PATH+k,'a+') as the_file:
#                the_file.write(val)
#                the_file.write("\r\n")
